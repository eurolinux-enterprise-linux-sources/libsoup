commit a87e5833024a21a4e2aa845e039121377e921738
Author: Dan Winship <danw@gnome.org>
Date:   Sun May 16 03:31:38 2010 -0400

    Fix SoupSessionAsync to handle very early aborts better
    
    If soup_session_abort() was called while we were doing async DNS,
    things could get confused and it would end up trying to use a freed
    SoupSocket. Fix that up by always properly using GCancellables during
    SoupSocket connection, so that we can cancel any outstanding
    operations if the socket is destroyed, and add a regression test for
    that.
    
    That then fixes a known leak in misc-test's early-abort case, but
    makes it crash instead, so we fix that by using a weak pointer in
    SoupSessionAsync to detect when the session has been destroyed before
    the callback is invoked. This then creates/reveals additional leaks in
    that test case, which require additional fixes.
    
    The relevant APIs are obviously lousy (in the way most pre-gio async
    APIs in GNOME were), but can't really be fixed at this point without
    breaking ABI. To be fixed in the gio-based API...
    
    https://bugzilla.gnome.org/show_bug.cgi?id=618641

[rebased for libsoup-2.28. The misc-test portion couldn't be rebased
since it depends on a feature that doesn't exist in libsoup-2.28]

--- libsoup-2.28.2/libsoup/soup-connection.c.rh657622	2009-12-16 09:00:57.000000000 -0500
+++ libsoup-2.28.2/libsoup/soup-connection.c	2012-06-27 10:18:01.923390593 -0400
@@ -363,7 +363,21 @@ static void
 socket_connect_result (SoupSocket *sock, guint status, gpointer user_data)
 {
 	SoupConnectionAsyncConnectData *data = user_data;
-	SoupConnectionPrivate *priv = SOUP_CONNECTION_GET_PRIVATE (data->conn);
+	SoupConnectionPrivate *priv;
+
+	if (!data->conn) {
+		if (data->callback) {
+			data->callback (NULL, SOUP_STATUS_CANCELLED,
+					data->callback_data);
+		}
+		g_slice_free (SoupConnectionAsyncConnectData, data);
+		return;
+	}
+
+	g_object_remove_weak_pointer (G_OBJECT (data->conn),
+				      (gpointer *)&data->conn);
+
+	priv = SOUP_CONNECTION_GET_PRIVATE (data->conn);
 
 	if (!SOUP_STATUS_IS_SUCCESSFUL (status))
 		goto done;
@@ -417,6 +431,7 @@ soup_connection_connect_async (SoupConne
 	data->conn = conn;
 	data->callback = callback;
 	data->callback_data = user_data;
+	g_object_add_weak_pointer (G_OBJECT (conn), (gpointer *)&data->conn);
 
 	priv->socket =
 		soup_socket_new (SOUP_SOCKET_REMOTE_ADDRESS, priv->remote_addr,
@@ -528,6 +543,7 @@ soup_connection_disconnect (SoupConnecti
 	g_return_if_fail (SOUP_IS_CONNECTION (conn));
 	priv = SOUP_CONNECTION_GET_PRIVATE (conn);
 
+	priv->state = SOUP_CONNECTION_DISCONNECTED;
 	if (!priv->socket)
 		return;
 
@@ -537,11 +553,6 @@ soup_connection_disconnect (SoupConnecti
 	g_object_unref (priv->socket);
 	priv->socket = NULL;
 
-	/* Don't emit "disconnected" if we aren't yet connected */
-	if (priv->state < SOUP_CONNECTION_IDLE)
-		return;
-
-	priv->state = SOUP_CONNECTION_DISCONNECTED;
 	/* NB: this might cause conn to be destroyed. */
 	g_signal_emit (conn, signals[DISCONNECTED], 0);
 }
--- libsoup-2.28.2/libsoup/soup-session-async.c.rh657622	2009-12-16 09:03:54.000000000 -0500
+++ libsoup-2.28.2/libsoup/soup-session-async.c	2012-06-27 10:17:32.065388268 -0400
@@ -250,10 +250,19 @@ done:
 }
 
 static void
-got_connection (SoupConnection *conn, guint status, gpointer session)
+got_connection (SoupConnection *conn, guint status, gpointer user_data)
 {
+	gpointer *session_p = user_data;
+	SoupSession *session = *session_p;
 	SoupAddress *tunnel_addr;
 
+	if (!session) {
+		g_slice_free (gpointer, session_p);
+		return;
+	}
+	g_object_remove_weak_pointer (G_OBJECT (session), session_p);
+	g_slice_free (gpointer, session_p);
+
 	if (status != SOUP_STATUS_OK) {
 		/* There may have been messages waiting for the
 		 * connection count to go down, so queue a run_queue.
@@ -340,8 +349,13 @@ run_queue (SoupSessionAsync *sa)
 			continue;
 
 		if (soup_connection_get_state (conn) == SOUP_CONNECTION_NEW) {
+			gpointer *session_p;
+
+			session_p = g_slice_new (gpointer);
+			*session_p = session;
+			g_object_add_weak_pointer (G_OBJECT (session), session_p);
 			soup_connection_connect_async (conn, got_connection,
-						       session);
+						       session_p);
 		} else
 			soup_session_send_queue_item (session, item, conn);
 	}
--- libsoup-2.28.2/libsoup/soup-socket.c.rh657622	2009-11-22 09:43:35.000000000 -0500
+++ libsoup-2.28.2/libsoup/soup-socket.c	2012-06-27 10:17:32.068388269 -0400
@@ -91,6 +91,8 @@ typedef struct {
 
 	GMutex *iolock, *addrlock;
 	guint timeout;
+
+	GCancellable *connect_cancel;
 } SoupSocketPrivate;
 #define SOUP_SOCKET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SOUP_TYPE_SOCKET, SoupSocketPrivate))
 
@@ -152,6 +154,8 @@ finalize (GObject *object)
 {
 	SoupSocketPrivate *priv = SOUP_SOCKET_GET_PRIVATE (object);
 
+	if (priv->connect_cancel)
+		g_object_unref (priv->connect_cancel);
 	if (priv->iochannel)
 		disconnect_internal (priv);
 
@@ -572,6 +576,16 @@ typedef struct {
 	gpointer user_data;
 } SoupSocketAsyncConnectData;
 
+static void
+free_sacd (SoupSocketAsyncConnectData *sacd)
+{
+	if (sacd->cancel_id)
+		g_signal_handler_disconnect (sacd->cancellable, sacd->cancel_id);
+	g_object_unref (sacd->cancellable);
+	g_object_unref (sacd->sock);
+	g_slice_free (SoupSocketAsyncConnectData, sacd);
+}
+
 static gboolean
 idle_connect_result (gpointer user_data)
 {
@@ -579,9 +593,8 @@ idle_connect_result (gpointer user_data)
 	SoupSocketPrivate *priv = SOUP_SOCKET_GET_PRIVATE (sacd->sock);
 	guint status;
 
+	priv->connect_cancel = NULL;
 	priv->watch_src = NULL;
-	if (sacd->cancel_id)
-		g_signal_handler_disconnect (sacd->cancellable, sacd->cancel_id);
 
 	if (priv->sockfd == -1) {
 		if (g_cancellable_is_cancelled (sacd->cancellable))
@@ -592,7 +605,7 @@ idle_connect_result (gpointer user_data)
 		status = SOUP_STATUS_OK;
 
 	sacd->callback (sacd->sock, status, sacd->user_data);
-	g_slice_free (SoupSocketAsyncConnectData, sacd);
+	free_sacd (sacd);
 	return FALSE;
 }
 
@@ -641,16 +654,17 @@ static void
 got_address (SoupAddress *addr, guint status, gpointer user_data)
 {
 	SoupSocketAsyncConnectData *sacd = user_data;
+	SoupSocketPrivate *priv = SOUP_SOCKET_GET_PRIVATE (sacd->sock);
+
+	priv->connect_cancel = NULL;
 
-	if (!SOUP_STATUS_IS_SUCCESSFUL (status)) {
+	if (SOUP_STATUS_IS_SUCCESSFUL (status)) {
+		soup_socket_connect_async (sacd->sock, sacd->cancellable,
+					   sacd->callback, sacd->user_data);
+	} else
 		sacd->callback (sacd->sock, status, sacd->user_data);
-		g_slice_free (SoupSocketAsyncConnectData, sacd);
-		return;
-	}
 
-	soup_socket_connect_async (sacd->sock, sacd->cancellable,
-				   sacd->callback, sacd->user_data);
-	g_slice_free (SoupSocketAsyncConnectData, sacd);
+	free_sacd (sacd);
 }
 
 static void
@@ -731,15 +745,23 @@ soup_socket_connect_async (SoupSocket *s
 	g_return_if_fail (priv->remote_addr != NULL);
 
 	sacd = g_slice_new0 (SoupSocketAsyncConnectData);
-	sacd->sock = sock;
-	sacd->cancellable = cancellable;
+	sacd->sock = g_object_ref (sock);
+	sacd->cancellable = cancellable ? g_object_ref (cancellable) : g_cancellable_new ();
 	sacd->callback = callback;
 	sacd->user_data = user_data;
 
+	priv->connect_cancel = sacd->cancellable;
+
+	if (g_cancellable_is_cancelled (priv->connect_cancel)) {
+		priv->watch_src = soup_add_completion (priv->async_context,
+						       idle_connect_result, sacd);
+		return;
+	}
+
 	if (!soup_address_get_sockaddr (priv->remote_addr, NULL)) {
 		soup_address_resolve_async (priv->remote_addr,
 					    priv->async_context,
-					    cancellable,
+					    sacd->cancellable,
 					    got_address, sacd);
 		return;
 	}
@@ -760,12 +782,10 @@ soup_socket_connect_async (SoupSocket *s
 						  priv->timeout * 1000,
 						  connect_timeout, sacd);
 		}
-		if (cancellable) {
-			sacd->cancel_id =
-				g_signal_connect (cancellable, "cancelled",
-						  G_CALLBACK (async_cancel),
-						  sacd);
-		}
+		sacd->cancel_id =
+			g_signal_connect (sacd->cancellable, "cancelled",
+					  G_CALLBACK (async_cancel),
+					  sacd);
 	} else {
 		priv->watch_src = soup_add_completion (priv->async_context,
 						       idle_connect_result, sacd);
@@ -805,28 +825,35 @@ soup_socket_connect_sync (SoupSocket *so
 	g_return_val_if_fail (priv->sockfd == -1, SOUP_STATUS_MALFORMED);
 	g_return_val_if_fail (priv->remote_addr != NULL, SOUP_STATUS_MALFORMED);
 
+	if (cancellable)
+		g_object_ref (cancellable);
+	else
+		cancellable = g_cancellable_new ();
+	priv->connect_cancel = cancellable;
+
 	if (!soup_address_get_sockaddr (priv->remote_addr, NULL)) {
 		status = soup_address_resolve_sync (priv->remote_addr,
 						    cancellable);
-		if (!SOUP_STATUS_IS_SUCCESSFUL (status))
+		if (!SOUP_STATUS_IS_SUCCESSFUL (status)) {
+			priv->connect_cancel = NULL;
+			g_object_unref (cancellable);
 			return status;
+		}
 	}
 
-	if (cancellable) {
-		cancel_id = g_signal_connect (cancellable, "cancelled",
-					      G_CALLBACK (sync_cancel), sock);
-	}
+	cancel_id = g_signal_connect (cancellable, "cancelled",
+				      G_CALLBACK (sync_cancel), sock);
 
 	status = socket_connect_internal (sock);
+	priv->connect_cancel = NULL;
 
-	if (cancellable) {
-		if (status != SOUP_STATUS_OK &&
-		    g_cancellable_is_cancelled (cancellable)) {
-			status = SOUP_STATUS_CANCELLED;
-			disconnect_internal (priv);
-		}
-		g_signal_handler_disconnect (cancellable, cancel_id);
+	if (status != SOUP_STATUS_OK &&
+	    g_cancellable_is_cancelled (cancellable)) {
+		status = SOUP_STATUS_CANCELLED;
+		disconnect_internal (priv);
 	}
+	g_signal_handler_disconnect (cancellable, cancel_id);
+	g_object_unref (cancellable);
 
 	return status;
 }
@@ -1031,7 +1058,10 @@ soup_socket_disconnect (SoupSocket *sock
 	g_return_if_fail (SOUP_IS_SOCKET (sock));
 	priv = SOUP_SOCKET_GET_PRIVATE (sock);
 
-	if (g_mutex_trylock (priv->iolock)) {
+	if (priv->connect_cancel) {
+		g_cancellable_cancel (priv->connect_cancel);
+		return;
+	} else if (g_mutex_trylock (priv->iolock)) {
 		if (priv->iochannel)
 			disconnect_internal (priv);
 		else
